

/* VECTOR OPERATOR */

template< class T, class Alloc >
bool operator==( const std::vector<T,Alloc>& lhs, const std::vector<T,Alloc>& rhs );

template< class T, class Alloc >
bool operator!=( const std::vector<T,Alloc>& lhs, const std::vector<T,Alloc>& rhs );
(2)	(until C++20)

template< class T, class Alloc >
bool operator<( const std::vector<T,Alloc>& lhs, const std::vector<T,Alloc>& rhs );
(3)	(until C++20)

template< class T, class Alloc >
bool operator<=( const std::vector<T,Alloc>& lhs, const std::vector<T,Alloc>& rhs );
(4)	(until C++20)

template< class T, class Alloc >
bool operator>( const std::vector<T,Alloc>& lhs, const std::vector<T,Alloc>& rhs );
(5)	(until C++20)

template< class T, class Alloc >
bool operator>=( const std::vector<T,Alloc>& lhs, const std::vector<T,Alloc>& rhs );
(6)	(until C++20)

1-2) Checks if the contents of lhs and rhs are equal, that is, they have the same number of elements and each element in lhs compares equal with the element in rhs at the same position.
3-6) Compares the contents of lhs and rhs lexicographically. The comparison is performed by a function equivalent to std::lexicographical_compare.


lhs, rhs	-	vectors whose contents to compare
-T must meet the requirements of EqualityComparable in order to use overloads (1-2).
-T must meet the requirements of LessThanComparable in order to use overloads (3-6). The ordering relation must establish total order.




Expression	Return type	Equivalent expression
i++	It	            It               ip = i; ++i; return ip;
*i++	        reference

	template < class iterator >
	class vector_reverseIterator 
    {
            
		public :
			typedef iterator							iterator_type;
			typedef typename iterator::value_type		value_type;
			typedef typename iterator::reference		reference;
			typedef typename iterator::const_reference	const_reference;
			typedef typename iterator::pointer			pointer;
			typedef typename iterator::const_pointer	const_pointer;
			typedef typename iterator::difference_type	difference_type;

        private :
			pointer _ptr;

			vector_reverseIterator(void) {}
			vector_reverseIterator(pointer ptr) { _ptr = ptr; }
			//vector_reverseIterator(vectorIterator<value_type> const &src) { _ptr = src.operator->(); }
			vector_reverseIterator(vector_reverseIterator const &src) { *this = src; } ;
			vector_reverseIterator &operator=(vector_reverseIterator const &src) { _ptr = src.operator->(); return (*this); }
			~vector_reverseIterator() {}

			vector_reverseIterator operator ++() {
				_ptr--;
				return (*this);
			}
		
			vector_reverseIterator operator ++(int) {
				_ptr--;
				return (vector_reverseIterator(_ptr + 1));
			}
		
			vector_reverseIterator operator --() {
				_ptr++;
				return (*this);
			}
		
			vector_reverseIterator operator --(int) {
				_ptr++;
				return (vector_reverseIterator(_ptr - 1));
			}

			void operator +=(difference_type v) { _ptr -= v; }
			void operator -=(difference_type v) { _ptr += v; }

			bool operator ==(vector_reverseIterator const& v) const { return _ptr == v._ptr; }
			bool operator !=(vector_reverseIterator const& v) const { return _ptr != v._ptr; }
			bool operator <(vector_reverseIterator const& v) const { return _ptr < v._ptr; }
			bool operator <=(vector_reverseIterator const& v) const { return _ptr <= v._ptr; }
			bool operator >(vector_reverseIterator const& v) const { return _ptr > v._ptr; }
			bool operator >=(vector_reverseIterator const& v) const { return _ptr >= v._ptr; }

			vector_reverseIterator operator +(difference_type v) { return vector_reverseIterator(_ptr - v); }
			vector_reverseIterator operator -(difference_type v) { return vector_reverseIterator(_ptr + v); }
			difference_type operator +(vector_reverseIterator v) { return _ptr - v._ptr; }
			difference_type operator -(vector_reverseIterator v) { return _ptr + v._ptr; }

			reference operator *() { return *_ptr; }
			const_reference operator *() const { return *_ptr; }
			pointer operator ->() { return _ptr; }
			pointer operator ->() const { return _ptr; }
			reference operator [](difference_type n) { return *(_ptr + n); }
			const_reference operator [](difference_type n) const { return *(_ptr + n); }

			pointer get_ptr() { return _ptr; }

	}; 



    

    	template < class Iter >
	class const_vector_reverseIterator {
		public :
            typedef Iter iterator_type;
            typedef typename iterator_traits<Iter>::iterator_category iterator_category;
            typedef typename iterator_traits<Iter>::value_type value_type;
            typedef typename iterator_traits<Iter>::difference_type difference_type;
            typedef typename iterator_traits<Iter>::pointer pointer;
            typedef typename iterator_traits<Iter>::reference reference;

        private :
			pointer _ptr;

			const_vector_reverseIterator(void) {}
			const_vector_reverseIterator(pointer ptr) { _ptr = ptr; }
			const_vector_reverseIterator(const_vector_reverseIterator const &src) { *this = src; } ;
			const_vector_reverseIterator &operator=(const_vector_reverseIterator const &src) { _ptr = src.operator->(); return (*this); }
			~const_vector_reverseIterator() {}

			const_vector_reverseIterator operator ++() {
				_ptr--;
				return (*this);
			}

			const_vector_reverseIterator operator ++(int) {
				_ptr--;
				return (const_vector_reverseIterator(_ptr + 1));
			}

			const_vector_reverseIterator operator --() {
				_ptr++;
				return (*this);
			}
		
			const_vector_reverseIterator operator --(int) {
				_ptr++;
				return (const_vector_reverseIterator(_ptr - 1));
			}

			bool operator ==(const_vector_reverseIterator const& v) const { return _ptr == v._ptr; }
			bool operator !=(const_vector_reverseIterator const& v) const { return _ptr != v._ptr; }
			bool operator <(const_vector_reverseIterator const& v) const { return _ptr < v._ptr; }
			bool operator <=(const_vector_reverseIterator const& v) const { return _ptr <= v._ptr; }
			bool operator >(const_vector_reverseIterator const& v) const { return _ptr > v._ptr; }
			bool operator >=(const_vector_reverseIterator const& v) const { return _ptr >= v._ptr; }

			const_vector_reverseIterator operator +(difference_type v) { return const_vector_reverseIterator(_ptr - v); }
			const_vector_reverseIterator operator -(difference_type v) { return const_vector_reverseIterator(_ptr + v); }
			difference_type operator +(const_vector_reverseIterator v) { return _ptr - v._ptr; }
			difference_type operator -(const_vector_reverseIterator v) { return _ptr + v._ptr; }

			const_reference operator *() const { return *_ptr; }
			pointer operator ->() { return _ptr; }
			pointer operator ->() const { return _ptr; }
			const_reference operator [](difference_type n) const { return *(_ptr + n); }

			pointer get_ptr() { return _ptr; }
	};


	iterator insert(iterator position, const value_type &val)
	{
    	iterator old_head = begin();

    	size_t offset = 0;

    	insert(position, 1, val);

    	offset = begin() - old_head;

    	return position + offset;
	}



	void 			insert (iterator position, size_type n, const value_type& val)
	{
				if (position > this->end() || position < this->begin())
					return ;
				while (this->_size + n > this->_capacity)	
					this->reserve(this->_capacity * 2);
				for (size_t i = 0; i <= n; i++){
					position = this->insert(position, val);
				}
			}

			iterator	insert(iterator position, const value_type& val) .
			{
				iterator fit;
				difference_type diff = position - begin();

				if (capacity() == size())
					_extend();
				fit = begin() + diff;

				vector tmp(fit, end());
				for (size_t i = 0; i < tmp.size(); i++)
					pop_back();
				push_back(val);
				iterator it = tmp.begin();
				for (size_t i = 0; i < tmp.size(); i++, it++)
					push_back(*it);
				return begin() + diff;
			};

			void insert(iterator position, size_type n, const value_type& val) 
			{
				difference_type	diff = position - begin();

				while (_size_alloc - _size < n)
					_extend();
				vector tmp(begin() + diff, end());
				for (size_t i = 0; i < tmp.size(); i++)
					pop_back();
				while (n-- > 0)
					push_back(val);
				for (iterator it = tmp.begin(); it != tmp.end(); it++)
					push_back(*it);
			}
